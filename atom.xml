<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LTC&#39;s Home</title>
  
  <subtitle>有心情的话随便写写</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-08T13:00:21.705Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>李天成</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>北极通讯网络（最小生成树）</title>
    <link href="http://example.com/2022/08/07/2022-8-7/"/>
    <id>http://example.com/2022/08/07/2022-8-7/</id>
    <published>2022-08-07T13:52:28.000Z</published>
    <updated>2022-08-08T13:00:21.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h1><p>555这一天天累得要死到现在作业还没写完，我受不了辣！</p><p>本来题解打算写另一道线段树的题的题解的，然而那题实在麻烦，而且我也没有完全弄懂，所以那篇先鸽了，转而写了这篇。</p><h1 id="题目引入"><a href="#题目引入" class="headerlink" title="题目引入"></a>题目引入</h1><p>北极的某区域共有n座村庄( 1 ≤ n ≤ 500 )，每座村庄的坐标用一对整数(x, y)表示，其中 0 ≤ x, y ≤ 10000。为了加强联系，决定在村庄之间建立通讯网络。通讯工具可以是无线电收发机，也可以是卫星设备。所有的村庄都可以拥有一部无线电收发机， 且所有的无线电收发机型号相同。但卫星设备数量有限，只能给一部分村庄配备卫星设备。  不同型号的无线电收发机有一个不同的参数d，两座村庄之间的距离如果不超过d就可以用该型号的无线电收发机直接通讯，d值越大的型号价格越贵。拥有卫星设备的两座村庄无论相距多远都可以直接通讯。</p><p>现在有k台卫星设备，请你编写程序计算出如何分配可以使所拥有的无线电收发机的d值最小，并保证任意两个村庄都可以直接或间接通讯。</p><span id="more"></span><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>由于是一本通上的题，上面大写的几个字“最小生成树”，自然要往这方面去想。虽然题目说了很多也很复杂，但是我们实际剖析一下，翻译过来就是，n个结点，使图连通且连通的边权的最大值最小。但是，这道题复杂就复杂在它引入了一个有点麻烦的变量，卫星设备。卫星设备可以使两结点间距离变为0 。</p><p>于是我一看，两点间距离变0，还要使最大的边最小，那我们就贪心不就行了吗？</p><p>那时候正好赶上要中午吃饭没来得及细想，一想写一个kruskal先求出来最小生成树，这样保证最大边权一定小，然后按着边权从大到小分配卫星设备，这样逐步割掉大边，就让最大边尽可能的小了。于是，理着思路就写出了一份这样的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,s,p,mx,my,tot,f[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">village</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;vil[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">double</span> w;</span><br><span class="line">&#125;edge[N*N],tr[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge x,Edge y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x]==x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;p);</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;vil[i].x,&amp;vil[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">mx=(vil[i].x-vil[j].x); my=(vil[i].y-vil[j].y);</span><br><span class="line">edge[++tot].w=<span class="built_in">sqrt</span>(mx*mx+my*my); edge[tot].x=j; edge[tot].y=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+<span class="number">1</span>+tot,cmp);</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>,res=s; </span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tot&lt;p<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(edge[now].x)!=<span class="built_in">find</span>(edge[now].y))&#123;</span><br><span class="line">f[f[edge[now].y]]=<span class="built_in">find</span>(edge[now].x);</span><br><span class="line">tr[++tot].x=edge[now].x; tr[tot].y=edge[now].y;</span><br><span class="line">tr[tot].w=edge[now].w;</span><br><span class="line">&#125;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line">now=tot;</span><br><span class="line"><span class="keyword">while</span>(res&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[tr[now].x])&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[tr[now].y])&#123;</span><br><span class="line">res-=<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res-=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[tr[now].y])&#123;</span><br><span class="line">res-=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">st[tr[now].x]=st[tr[now].y]=<span class="number">1</span>;</span><br><span class="line">now--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((st[tr[now].x]==<span class="number">0</span>&amp;&amp;st[tr[now].y]==<span class="number">1</span>)||(st[tr[now].x]==<span class="number">1</span>&amp;&amp;!st[tr[now].y]==<span class="number">0</span>))&#123;</span><br><span class="line">now--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,tr[now].w);</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是</strong></p><p>这个想法乍一看似乎没问题，实际上却忽略了一种情况。我们假设有这样一个图（由于我不会画图，大家只好凑合看了，裸数字代表结点，——代表边，（）里的数字代表边权）。</p><p>1  ——（100）——    2    ——（1）——    3    ——（100）——   4   </p><p>如果此时有三台卫星设备，按照上面的理论，我们会发现我们只能解决掉一组100，但剩下的一组100我们就无能为力了。这样剩下的最大边就是100。可我们会发现如果给1,2,4装上的话剩余最大边是1。问题出在哪里了呢？</p><p>问题就在于，最小生成树中，即使相邻的两节点并没有都装上卫星设备，这条边也不一定要保留。断边就像是两个悬崖间的一条河，他们分别在对岸，但他们可以选择转身绕道，绕到与自己连通的最近的卫星设备（现实中比如找一个机场飞过去），再跳到离对方最近的卫星设备，这样的最短路就有可能是二者离最近卫星设备距离之和（当然本题不要求找最短路，因此只要本集合内有卫星设备就可以了）。</p><p>那么我们应该怎么把这一点考虑进去呢，刚刚也提到了，找和自己连通的卫星设备，也就是自己所在集合内只要有一台卫星设备，且这个集合是连通的，就一定可行。易知（这里真的易知，不知的动动脑袋思考一下），有k个设备，我们就要把整个图分为k个不同的集合，这样同一个集合内直接找，不同集合通过卫星设备中转。</p><p>这样思路就出来了，接下来我们从小到大枚举边的长度（不用一个一个长度枚举，往里加边就行，给边排一下序），我们知道，在一开始没连边的情况下，共有n个集合，全连上则变成一个集合，因此在加边的过程中，集合数量是在不断减小的，直到我们加完某条边，发现恰好剩余k个集合，那么这条边的长度就是我们要求的长度。至于怎么看还有几个集合，用并查集维护就ok，每次不同集合合并，就把当前剩余集合数-1。由于是从小到大逐渐枚举，因此正确性可以保证，最后上代码，没什么好说的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> n,f[N],s,p,tot,mx,my;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">village</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;vil[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">double</span> w;</span><br><span class="line">&#125;edge[N*N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge x,Edge y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x]==x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line"><span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f1=<span class="built_in">find</span>(x),f2=<span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(f1!=f2)&#123;</span><br><span class="line">f[f2]=f1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;p);</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;vil[i].x,&amp;vil[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">mx=(vil[i].x-vil[j].x); my=(vil[i].y-vil[j].y);</span><br><span class="line">edge[++tot].w=<span class="built_in">sqrt</span>(mx*mx+my*my); edge[tot].x=j; edge[tot].y=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+<span class="number">1</span>+tot,cmp);</span><br><span class="line"><span class="keyword">int</span> d=<span class="number">1</span>,res=p;</span><br><span class="line"><span class="keyword">while</span>(res&gt;s)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(edge[d].x)!=<span class="built_in">find</span>(edge[d].y))&#123;</span><br><span class="line"><span class="built_in">uni</span>(edge[d].x,edge[d].y);</span><br><span class="line">res--;</span><br><span class="line">&#125;</span><br><span class="line">d++;</span><br><span class="line">&#125;</span><br><span class="line">d--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,edge[d].w);</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这个题浪费了我整整半天时间（也不能说浪费吧，也许通过这个对最小生成树更加掌握了）。555昨天真是一点作业没写，我要摆烂辣！假期过得也太快辣！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;作者的话&quot;&gt;&lt;a href=&quot;#作者的话&quot; class=&quot;headerlink&quot; title=&quot;作者的话&quot;&gt;&lt;/a&gt;作者的话&lt;/h1&gt;&lt;p&gt;555这一天天累得要死到现在作业还没写完，我受不了辣！&lt;/p&gt;
&lt;p&gt;本来题解打算写另一道线段树的题的题解的，然而那题实在麻烦，而且我也没有完全弄懂，所以那篇先鸽了，转而写了这篇。&lt;/p&gt;
&lt;h1 id=&quot;题目引入&quot;&gt;&lt;a href=&quot;#题目引入&quot; class=&quot;headerlink&quot; title=&quot;题目引入&quot;&gt;&lt;/a&gt;题目引入&lt;/h1&gt;&lt;p&gt;北极的某区域共有n座村庄( 1 ≤ n ≤ 500 )，每座村庄的坐标用一对整数(x, y)表示，其中 0 ≤ x, y ≤ 10000。为了加强联系，决定在村庄之间建立通讯网络。通讯工具可以是无线电收发机，也可以是卫星设备。所有的村庄都可以拥有一部无线电收发机， 且所有的无线电收发机型号相同。但卫星设备数量有限，只能给一部分村庄配备卫星设备。  不同型号的无线电收发机有一个不同的参数d，两座村庄之间的距离如果不超过d就可以用该型号的无线电收发机直接通讯，d值越大的型号价格越贵。拥有卫星设备的两座村庄无论相距多远都可以直接通讯。&lt;/p&gt;
&lt;p&gt;现在有k台卫星设备，请你编写程序计算出如何分配可以使所拥有的无线电收发机的d值最小，并保证任意两个村庄都可以直接或间接通讯。&lt;/p&gt;</summary>
    
    
    
    
    <category term="最小生成树" scheme="http://example.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>迟到半年的博客</title>
    <link href="http://example.com/2022/08/02/2022-8-2/"/>
    <id>http://example.com/2022/08/02/2022-8-2/</id>
    <published>2022-08-02T13:54:23.000Z</published>
    <updated>2022-08-02T14:18:49.545Z</updated>
    
    <content type="html"><![CDATA[<p>终于把博客迁移过来了！没想到这一拖就是半年，最开始是网课没时间（其实就是玩的太过了，完全把这事置之脑后了），后来五月份又换了电脑，想更新还得迁移一下，快考试了没时间弄了。等到考完试就是oi集训，一下又是两周过去，这两天才匀出时间迁移。（我作业还一点没动呢）</p><span id="more"></span><p>今天随便写写，测试一下，过两天写一个线段树板子题的题解（昨天一天就想他这一道题了，到现在也没完全弄懂）。</p><h1 id="祝每个看到这里的人事事顺心如意！感谢你们的支持！"><a href="#祝每个看到这里的人事事顺心如意！感谢你们的支持！" class="headerlink" title="祝每个看到这里的人事事顺心如意！感谢你们的支持！"></a>祝每个看到这里的人事事顺心如意！感谢你们的支持！</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于把博客迁移过来了！没想到这一拖就是半年，最开始是网课没时间（其实就是玩的太过了，完全把这事置之脑后了），后来五月份又换了电脑，想更新还得迁移一下，快考试了没时间弄了。等到考完试就是oi集训，一下又是两周过去，这两天才匀出时间迁移。（我作业还一点没动呢）&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>第一次使用图床</title>
    <link href="http://example.com/2022/03/25/22-3-25/"/>
    <id>http://example.com/2022/03/25/22-3-25/</id>
    <published>2022-03-25T12:11:45.000Z</published>
    <updated>2022-03-25T12:38:03.669Z</updated>
    
    <content type="html"><![CDATA[<p>​    知道自己好久没更了，但没想到居然有这么久。上次更新已经是大概四十天前的事了。</p><p>​    这次更新想试试图床功能，随便传一张实验一下，这样以后的博文就能图文并茂啦（实际上并没有什么配图的必要）。目测是成功了。</p><span id="more"></span><p>​    <img src="https://s3.bmp.ovh/imgs/2022/03/13fcd5437dd1a79f.jpg"></p><p>​    疫情宅在家里实在是太累了，现在就是渴望自由，非常渴望。我感觉自己快要憋出抑郁症来了，每天重复着机械，枯燥的生活，能干的事就这么些。特别想出去旅游，出去玩。疫情这两年，连长春都没出过，现在一封城，连小区都出不去了，更不用提旅游了。每天宅在家上网看别人旅游，从2020年就开始规划去哪玩，怎么玩，有机会一定要去哪哪哪，两年过去了，连长春都没出去。如今病毒致死率降低，越来越多的人也打疫苗了，期待政策能逐渐放缓，一年内能恢复到疫情前的一半就行。只是这动态清零望不到尽头啊。</p><p>​    前两天突发奇想，我也可以搬运一些油管上的铁道视频，顺便尽我所能的翻译成熟肉，这样一方面找点有乐趣的事做，也能锻炼一下自己的日语能力。不过烤肉过程会很艰辛，时间也会比较长就是了。只不过要烤肉就得装Pr一类的东西，我现在这个老电脑c盘就剩一点几个G，装不下了。这两天正打算自己动手装一台新电脑，可惜疫情又封城，我怕到时候配件邮不过来，只得暂时作罢。</p><p>​    最近oi方面有些松懈了，主要这文化课追的也太紧了，感觉我的水平完全挤不出留给竞赛的时间，各科学案，大练习，练习册，每天过着被作业逼着前进的生活，太痛苦了。另外就是oi跳入舒适圈了，总喜欢挑着线性dp，dfs，bfs这些题做，因为我已经比较熟练了，享受着切题的快感。其他算法的题有时候题目读都不愿意读完，更不愿意去深入思考。但我知道如果真的想要出成绩，就不能在舒适圈里重复的刷水题。期待我能逐渐端正态度吧。</p><p>​    最后，平日更新确实有点难，今天还有各科学案没写。但是我怕今天不更的话明天就更不愿意更了，就赶紧坐到电脑前随便写点感想，也算是走出舒适圈吧。等到换电脑后我会找时间找教程尝试页面宠物的，敬请期待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    知道自己好久没更了，但没想到居然有这么久。上次更新已经是大概四十天前的事了。&lt;/p&gt;
&lt;p&gt;​    这次更新想试试图床功能，随便传一张实验一下，这样以后的博文就能图文并茂啦（实际上并没有什么配图的必要）。目测是成功了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>复制书稿</title>
    <link href="http://example.com/2022/02/15/%E5%A4%8D%E5%88%B6%E4%B9%A6%E7%A8%BF/"/>
    <id>http://example.com/2022/02/15/%E5%A4%8D%E5%88%B6%E4%B9%A6%E7%A8%BF/</id>
    <published>2022-02-15T09:41:25.000Z</published>
    <updated>2022-02-15T13:15:06.892Z</updated>
    
    <content type="html"><![CDATA[<p>​    之前看大佬说要多写题解，帮助自己理清思路，然而我这种蒟蒻做的题都很基础以至于没什么可写的。今天这道dp的复制书稿做了五个多小时，前面推动态规划的时候想到前两天做的一道乘积最大还算顺利，但是后面输出方案的时候就卡住了。题里很关键的一句话就是多解的情况下尽可能的让前面的人少写！！！（我的做法貌似算完以后是最接近平均时间的方案？）第一次写题解，感觉有点语无伦次，不过反正也没人看，看的人也不一定能看懂，就当整理自己思路的学习笔记吧。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在要把m本有顺序的书分给k个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三和第四本书给同一个人抄写。</p><p>现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。k行的起始编号应该从小到大排列，如果有多解，则尽可能让前面的人少抄写。</p><span id="more"></span><h1 id="错误代码（70pts）"><a href="#错误代码（70pts）" class="headerlink" title="错误代码（70pts）"></a>错误代码（70pts）</h1><p>`#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int m,k,s[505],dp[505][505],way[505][505],y;<br>struct jg{<br>    int t,w;<br>}ans[505];<br>int main(){<br>    cin&gt;&gt;m&gt;&gt;k;<br>    for(int i=1;i&lt;=m;i++){<br>        cin&gt;&gt;y;<br>        s[i]=s[i-1]+y;<br>    }<br>    memset(dp,127,sizeof(dp));<br>    for(int i=0;i&lt;=k;i++){<br>        dp[i][0]=0;<br>        dp[0][i]=0;<br>    }<br>    for(int i=1;i&lt;=m;i++){<br>        dp[1][i]=s[i];<br>    }<br>    for(int i=2;i&lt;=k;i++){<br>        for(int j=1;j&lt;=m;j++){<br>            for(int h=0;h&lt;=j-1;h++){<br>                if(dp[i][j]&gt;max(s[j]-s[h],dp[i-1][h])){<br>                    dp[i][j]=max(s[j]-s[h],dp[i-1][h]);<br>                    way[i][j]=h;<br>                }<br>            }<br>        }<br>    }<br>    int p=k,q=m;<br>    while(p!=0){<br>        ans[p].w=q;<br>        ans[p].t=way[p][q]+1;<br>        q=way[p][q]; p–;<br>    }for(int i=1;i&lt;=k;i++){<br>        for(int j=0;j&lt;=m;j++){<br>            printf(“%d “,dp[i][j]);<br>        }<br>        cout&lt;&lt;endl;<br>    }<br>    for(int i=1;i&lt;=k;i++){<br>        cout&lt;&lt;ans[i].t&lt;&lt;” “&lt;&lt;ans[i].w&lt;&lt;endl;<br>    }</p><p>}`</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>​    首先因为每个人抄的书是连续的所以就想到了dp（其实是因为这道题在dp的题单里，划掉），我们用dp【i】【j】来表示前i个人抄完前j本书的 时候所用的最小时间。可以想到，当我们推导dp【i】【j】时我们应将dp【i-1】【k】（0&lt;=k&lt;j）也就是i-1个人抄k=0,1,2,3…j本书时所用的时间与第i个人抄写从第k+1到第j本所用的时间对比，二者的最大值即为让i抄k+1到j本书时i人抄j本所用的总时间。再将该方案与现有dp【i】【j】的最优方案对比，取二者的最小值。最终dp【k】【m】即为时间的最小值。</p><p>​    但！！！这道题并不需要我们输出时间，而是询问时间最小时的方案。于是我最开始想到用一个数组way【i】【j】存放dp【i】【j】的来路，但我恰恰被这块卡了一下午。因为局部的最优解不一定是尽可能让前面的人少抄写的方案。例如下面这个例子。</p><p><code>10 4 1 1 1 1 1 1 1 1 1 1</code></p><p>标准输出为</p><p><code>1 1 2 4 5 7 8 10</code></p><p>但我的错误输出为</p><p>1 2</p><p>3 4</p><p>5 7</p><p>8 10</p><p>​    可以看到，当我们让前两个人抄四本书时，最优方案为一人抄两本，时间为2。但当4人抄十本时，因为最大时间一定为3，所以前两人的分配方案为第一人一本，而第二人抄三本。</p><p>​    看别人题解的时候看到一种输出思路，是贪心的想法，因为dp的时候最大工作时间已经确定，所以我们按逆序（这里因为要后面的人尽可能大，所以逆序枚举）给每个人塞书，如果塞完当前这本他的工作量超时，说明他不应该抄这本，便结束他的工作，继续讨论他前一位的情况。如此塞完一圈正是最优解。最后附上AC了的代码。</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><p>`#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int m,k,s[505],dp[505][505],y,maxx;<br>struct jg{<br>    int t,w;<br>}ans[505];<br>int main(){<br>    cin&gt;&gt;m&gt;&gt;k;<br>    for(int i=1;i&lt;=m;i++){<br>        cin&gt;&gt;y;<br>        s[i]=s[i-1]+y;<br>    }<br>    memset(dp,127,sizeof(dp));<br>    for(int i=0;i&lt;=k;i++){<br>        dp[i][0]=0;<br>        dp[0][i]=0;<br>    }<br>    for(int i=1;i&lt;=m;i++){<br>        dp[1][i]=s[i];<br>    }<br>    for(int i=2;i&lt;=k;i++){<br>        for(int j=1;j&lt;=m;j++){<br>            for(int h=0;h&lt;=j-1;h++){<br>                if(dp[i][j]&gt;max(s[j]-s[h],dp[i-1][h])){<br>                    dp[i][j]=max(s[j]-s[h],dp[i-1][h]);}<br>            }<br>        }<br>    }<br>    maxx=dp[k][m];<br>    int p=maxx,q=m,a,b;<br>    for(int i=k;i&gt;=1;i–){<br>        p=maxx;<br>        a=q;<br>        while(p&gt;=0&amp;&amp;q&gt;=1){<br>            if(p-s[q]+s[q-1]&gt;=0){<br>                p=p-s[q]+s[q-1];<br>                q–;<br>            }else{<br>                ans[i].t=q+1;<br>                ans[i].w=a;<br>                break;<br>            }<br>        }<br>    }<br>    ans[1].t=q+1;<br>    ans[1].w=a;<br>    for(int i=1;i&lt;=k;i++){<br>        cout&lt;&lt;ans[i].t&lt;&lt;” “&lt;&lt;ans[i].w&lt;&lt;endl;<br>    }</p><p>}`</p><p>​    感觉这篇题解有点水，不过我本来只打算理一下思路的。话说我感觉我要发烧了，现在已经开始流鼻涕了。</p><p>​    算法的世界实在是深奥又奇妙，但钻研算法的过程正是其乐趣所在。好吧，这篇就这些。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    之前看大佬说要多写题解，帮助自己理清思路，然而我这种蒟蒻做的题都很基础以至于没什么可写的。今天这道dp的复制书稿做了五个多小时，前面推动态规划的时候想到前两天做的一道乘积最大还算顺利，但是后面输出方案的时候就卡住了。题里很关键的一句话就是多解的情况下尽可能的让前面的人少写！！！（我的做法貌似算完以后是最接近平均时间的方案？）第一次写题解，感觉有点语无伦次，不过反正也没人看，看的人也不一定能看懂，就当整理自己思路的学习笔记吧。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;现在要把m本有顺序的书分给k个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三和第四本书给同一个人抄写。&lt;/p&gt;
&lt;p&gt;现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。k行的起始编号应该从小到大排列，如果有多解，则尽可能让前面的人少抄写。&lt;/p&gt;</summary>
    
    
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>随缘更新啦</title>
    <link href="http://example.com/2022/02/10/22-2-10/"/>
    <id>http://example.com/2022/02/10/22-2-10/</id>
    <published>2022-02-10T04:15:14.000Z</published>
    <updated>2022-02-15T10:22:26.150Z</updated>
    
    <content type="html"><![CDATA[<p>​    不知道我的OI路能走到哪里呢，刚刚看了学长的一篇博客，十分感动，<a href="http://blogmb.com/?p=1536%E3%80%82">http://blogmb.com/?p=1536。</a></p><p>​    但愿我能抵住压力撑下去吧，撑到2022年11月份的noip就退役，但愿能如愿以偿的拿到省一。但愿没有什么意外，但愿我就是那个幸运儿。</p><span id="more"></span><p>​    加油！</p><p>​    今天这篇顺便试一下外链音乐播放器这个功能。歌曲的话选了夜鹿（yorushika）的所以我放弃了音乐，也挺适合此刻的心情的。顺便贴一段很喜欢的歌词。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1357953768&auto=0&height=66"></iframe><p>だから僕は音楽を辞めた - ヨルシカ (Yorushika)<br>間違ってるんだよ<br>わかってないよ あんたら人間も<br>本当も愛も世界も苦しさも人生も<br>どうでもいいよ<br>正しいかどうか知りたいのだって<br>防衛本能だ<br>考えたんだ あんたのせいだ</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    不知道我的OI路能走到哪里呢，刚刚看了学长的一篇博客，十分感动，&lt;a href=&quot;http://blogmb.com/?p=1536%E3%80%82&quot;&gt;http://blogmb.com/?p=1536。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​    但愿我能抵住压力撑下去吧，撑到2022年11月份的noip就退役，但愿能如愿以偿的拿到省一。但愿没有什么意外，但愿我就是那个幸运儿。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>一点小感想</title>
    <link href="http://example.com/2022/02/03/%E4%B8%80%E7%82%B9%E5%B0%8F%E6%84%9F%E6%83%B3/"/>
    <id>http://example.com/2022/02/03/%E4%B8%80%E7%82%B9%E5%B0%8F%E6%84%9F%E6%83%B3/</id>
    <published>2022-02-03T04:41:46.000Z</published>
    <updated>2022-02-03T07:54:26.828Z</updated>
    
    <content type="html"><![CDATA[<p>  过年回家聊天的时候受到高人指点，初一晚上本来想做两道oi题，却突然心血来潮想到白天的对话内容，便在b站和知乎上一顿找教程，终于花了三天时间搭出了这个个人博客，一直坐在电脑前找各种问题，腰酸背痛，眼冒金星。其实昨天晚上就想写了，但是不知为何网站成功上线后我第一时间想的不是赶紧写一篇博文而是选择先去调主题（笑）。</p><span id="more"></span><p>  b站和知乎上都说是无坑小白教程怎么怎么样的，看up主演示只要二十多分钟就轻松搭好，但当我实际上手却发现问题层出不穷，比如多打少打一个空格，github抽风式的连不上，字符的编码问题导致乱码，密码当成令牌输等等，感觉我已经把能踩的坑都踩了一遍。找bug的过程实在太难了，我也不知道具体是哪个的问题，有段时间甚至病急乱投医把能试的代码，改的方法都试了一遍，不过倒是奇迹般的修好了（所以我到现在也不知道那个时候问题出在哪）。</p><p>  现在还不是很熟悉这个，不过本来我就没打算太管它，有心情的时候随便写写，今后也慢慢试点花里胡哨的小功能。</p><h3 id="目前打算尝试的功能"><a href="#目前打算尝试的功能" class="headerlink" title="目前打算尝试的功能"></a>目前打算尝试的功能</h3><ul><li>评论区</li><li>打赏通道</li><li>音乐播放器</li><li>鼠标特效</li><li>背景</li><li>页面宠物</li></ul><p>​    我会不定时更新的（指猴年马月），毕竟平时没有多少时间，其他时间还得分给oi和娱乐，这个博客能想起来就随缘更吧。这三天为了博客连oi题都没做，不说了，动态规划太难了，滚去学习了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;  过年回家聊天的时候受到高人指点，初一晚上本来想做两道oi题，却突然心血来潮想到白天的对话内容，便在b站和知乎上一顿找教程，终于花了三天时间搭出了这个个人博客，一直坐在电脑前找各种问题，腰酸背痛，眼冒金星。其实昨天晚上就想写了，但是不知为何网站成功上线后我第一时间想的不是赶紧写一篇博文而是选择先去调主题（笑）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
